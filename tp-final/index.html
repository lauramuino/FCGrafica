<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Heightmap</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<!-- todo: https://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html implementar esto -->
		<script src="./js/three.js"></script>
		<script type="module">
			import {OrbitControls} from './js/OrbitControls.js';
			import * as dat from './js/dat.gui/build/dat.gui.module.js'
			var camera, scene, renderer, controls;
			init();
			map();
			tarrain();
			render();
			tick();


			function init(){
				//setting camera
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set(40,20,50);
				camera.lookAt(scene.position);

				//todo: dont remember what this is
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				lightHandler();

				//camera controls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener( 'change', render );
				// Set control center target to almost center of plane
				controls.target.set(0, 2, 0);
				controls.update();
			}

			
			function lightHandler(){
				// Debug
				const gui = new dat.GUI()
				//pointlight
				const light = new THREE.PointLight(0xffffff, 1);
				light.position.set(20,20,20);
				light.castShadow = true;
				scene.add(light);
				// Add Lightning management helper
				const helper = new THREE.PointLightHelper(light);
				scene.add(helper);
				
				// function to update light helper
				function updateLight() {
					helper.update();
				}
				
				// Add light and helper to GUI
				function addVec3ToGUI(gui, vector3, name, onChangeFn) {
					const folder = gui.addFolder(name);
					folder.add(vector3, 'x', -100, 100).onChange(onChangeFn);
					folder.add(vector3, 'y', 0, 100).onChange(onChangeFn);
					folder.add(vector3, 'z', -100, 100).onChange(onChangeFn);
					folder.open();
				}

				// GUI management for lightning
				gui.add(light, 'intensity', 0, 2, 0.01);
				gui.add(light, 'distance', 0, 40).onChange(updateLight);
				// Add light position and target position to GUI
				addVec3ToGUI(gui, light.position, 'position', updateLight);
			}

			//a line based grid, with the axes, for understanding visual results
			function map(){
				const size = 100;
				const divisions = 100;
				const gridHelper = new THREE.GridHelper(size, divisions);
				scene.add(gridHelper);
				
				//The X axis is red, Y axis is green, Z axis is blue.
				const axesHelper = new THREE.AxesHelper( 100 );
				scene.add( axesHelper );
			}
			
			function polarMapCoordenates(){
				const polarHelper = new THREE.PolarGridHelper();
				scene.add(polarHelper);
			}
			
			// Generates a hill on the given geometry around the centerpoint
			function generateHill(geometry){
				var maxRadious = 5
				var radious = Math.random() * maxRadious + 1;
				var totalMountains = 500
				// Keep track of min and max height for normalization
				var max = Math.pow(maxRadious,2)
				var min = 0
				// Choose random mountain center
				for (var j=0; j < totalMountains; j++) {
					var randomLocation = Math.floor(Math.random() * geometry.attributes.position.count)
					var centerX = geometry.attributes.position.array[3*randomLocation];
					var centerZ = geometry.attributes.position.array[3*randomLocation+2];
					// Calculate height for points inside the radious (other points are 0)
					for (var i=0; i <geometry.attributes.position.count; i++) {
						var coordX = geometry.attributes.position.array[3*i+0];
						var coordZ = geometry.attributes.position.array[3*i+2];
						var y = Math.max(Math.pow(radious,2) - (Math.pow((coordX - centerX),2) + Math.pow((coordZ - centerZ),2)),0)
						if (y > max) {
							max = y;
						}
						geometry.attributes.position.array[3*i+1] += (y - min)/(max-min); 
					}
				}
			}

			// Generates random heights
			function addRandomHeights(geometry) {
				for (var i=0; i <geometry.attributes.position.count; i++) {
					geometry.attributes.position.array[3*i+1] = Math.floor(Math.random() *5); 
				}
			}

			//with plane geometry
			function tarrain(){
				const width = 50; // Width along the X axis. Default is 1.
				const height = 50; // Height along the Y axis. Default is 1.
				const widthSegments = 1000; // Optional. Default is 1.
				const heightSegments = 1000; // Optional. Default is 1. 

				const geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
				geometry.rotateX(Math.PI/2);
				
				// Add heights
				// addRandomHeights(geometry);
				generateHill(geometry);

				
				const material = new THREE.MeshStandardMaterial({color:'white', side: THREE.DoubleSide});
				// var material = new THREE.MeshPhongMaterial({color: 0xdddddd, wireframe: true });
				const plane = new THREE.Mesh(geometry,material);
				scene.add(plane);
			}

			function render(){
				renderer.render(scene, camera);
			}

			function tick() {

				// Update Orbital Controls
				controls.update()

				// Render
				renderer.render(scene, camera)

				// Call tick again on the next frame
				window.requestAnimationFrame(tick)
			}
		</script>
	</body>
</html>