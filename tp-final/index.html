<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Heightmap</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<!-- todo: https://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html implementar esto -->
		<script src="./js/three.js"></script>
		<script type="module">
			import {OrbitControls} from './js/OrbitControls.js';
			import * as dat from './js/dat.gui/build/dat.gui.module.js'
			var camera, scene, renderer, controls;
			init();
			map();
			tarrain();
			render();
			tick();


			function init(){
				// Debug
				const gui = new dat.GUI()

				//setting camera
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set(40,20,50);
				camera.lookAt(scene.position);

				//todo: dont remember what this is
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//pointlight
				const light = new THREE.PointLight(0xffffff, 1);
				light.position.set(20,20,20);
				light.castShadow = true;
				scene.add(light);
				// Add Lightning management helper
				const helper = new THREE.PointLightHelper(light);
				scene.add(helper);
				
				// function to update light helper
				function updateLight() {
					helper.update();
				}
				
				// Add light and helper to GUI
				function addVec3ToGUI(gui, vector3, name, onChangeFn) {
					const folder = gui.addFolder(name);
					folder.add(vector3, 'x', -100, 100).onChange(onChangeFn);
					folder.add(vector3, 'y', 0, 100).onChange(onChangeFn);
					folder.add(vector3, 'z', -100, 100).onChange(onChangeFn);
					folder.open();
				}

				// GUI management for lightning
				gui.add(light, 'intensity', 0, 2, 0.01);
				gui.add(light, 'distance', 0, 40).onChange(updateLight);
				// Add light position and target position to GUI
				addVec3ToGUI(gui, light.position, 'position', updateLight);

				//camera controls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener( 'change', render );
				// Set control center target to almost center of plane
				controls.target.set(0, 5, 0);
				controls.update();
			}

			//todo: has a bug
			function manualMesh(){
				var size =2, step=1;
				var material = new THREE.LineBasicMaterial({color: 'white'});

				var geometry;
				var line;
				for(var i =-size; i<size; i+=step){
					const points = [];
					points.push(new THREE.Vector3(i, 0, i+1));
					points.push(new THREE.Vector3(size, 0, i));
					points.push(new THREE.Vector3(i, 0, -size));
					points.push(new THREE.Vector3(i, 0, size));

					geometry = new THREE.BufferGeometry().setFromPoints(points);
					line = new THREE.Line(geometry, material, THREE.LinePieces);
					scene.add(line);
				}
			}

			//a line based grid, with the helpers, for understanding visual results
			function map(){
				const size = 100;
				const divisions = 100;
				const gridHelper = new THREE.GridHelper(size, divisions);
				scene.add(gridHelper);

				//The X axis is red, Y axis is green, Z axis is blue.
				const axesHelper = new THREE.AxesHelper( 100 );
				scene.add( axesHelper );
			}

			function polarMapCoordenates(){
				const polarHelper = new THREE.PolarGridHelper();
				scene.add(polarHelper);
			}

			//with plane geometry
			function tarrain(){
				const width = 50; // Width along the X axis. Default is 1.
				const height = 50; // Height along the Y axis. Default is 1.
				const widthSegments = 100; // Optional. Default is 1.
				const heightSegments = 100; // Optional. Default is 1. 

				const geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
				geometry.rotateX(Math.PI/2);
				// Adding random height
				for (var i=0; i <geometry.attributes.position.count; i++) {
					geometry.attributes.position.array[3*i+1] = Math.floor(Math.random() *5); 
				}

				
				const material = new THREE.MeshStandardMaterial({color:'white', side: THREE.DoubleSide});
				// var material = new THREE.MeshPhongMaterial({color: 0xdddddd, wireframe: true });
				const plane = new THREE.Mesh(geometry,material);
				scene.add(plane);
			}

			function render(){
				renderer.render(scene, camera);
			}

			function tick() {

				// Update Orbital Controls
				controls.update()

				// Render
				renderer.render(scene, camera)

				// Call tick again on the next frame
				window.requestAnimationFrame(tick)
			}
		</script>
	</body>
</html>