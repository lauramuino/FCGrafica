<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Heightmap</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<!-- todo: https://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html implementar esto -->
		<script src="./js/three.js"></script>
		<script type="module">
			import {OrbitControls} from './js/OrbitControls.js';
			import * as dat from './js/dat.gui/build/dat.gui.module.js'
			var camera, scene, renderer, controls;
			var diffuse, pointlight_uniform;
			init();
			map();
			tarrain();
			render();
			tick();


			function init(){
				//setting camera
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set(40,20,50);
				camera.lookAt(scene.position);

				//todo: dont remember what this is
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				lightHandler();

				//camera controls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener( 'change', render );
				// Set control center target to almost center of plane
				controls.target.set(0, 2, 0);
				controls.update();
			}

			
			function lightHandler(){
				// Debug
				const gui = new dat.GUI()
				//pointlight
				const light = new THREE.PointLight(0xffffff, 1);
				light.position.set(20,20,20);
				light.castShadow = true;
				scene.add(light);
				// Add Lightning management helper
				const helper = new THREE.PointLightHelper(light);
				scene.add(helper);
				
				// function to update light helper
				function updateLight() {
					helper.update();
				}
				
				// Add light and helper to GUI
				function addVec3ToGUI(gui, vector3, name, onChangeFn) {
					const folder = gui.addFolder(name);
					folder.add(vector3, 'x', -50, 50).onChange(onChangeFn);
					folder.add(vector3, 'y', 0, 20).onChange(onChangeFn);
					folder.add(vector3, 'z', -50, 50).onChange(onChangeFn);
					folder.open();
				}

				// GUI management for lightning
				const lightFolder = gui.addFolder('lightning')
				// Add light position and target position to GUI
				addVec3ToGUI(lightFolder, light.position, 'position', updateLight);
				lightFolder.add(light, 'intensity', 0, 2, 0.01);
				lightFolder.add(light, 'distance', 0, 40).onChange(updateLight);



				// Add diffuse
				diffuse =  {type: 'c', value: new THREE.Color(0x0000ff)};
				var uniformsFolder = gui.addFolder('Uniforms');
				diffuse.guivalue = [diffuse.value.r * 255, diffuse.value.g * 255, diffuse.value.b * 255];
				var controller = uniformsFolder.addColor(diffuse, 'guivalue').name('diffuse');
				controller.onChange(function(value){
					this.object.value.setRGB(value[0]/255, value[1]/255, value[2]/255);
				});
				uniformsFolder.open();


				// Add color to light
				const col = { color: '#FFFFFF' }
				lightFolder.addColor(col, 'color').onChange(() => {
					light.color.set(col.color)
				})
				lightFolder.open();


				pointlight_uniform = light;
			}


			//a line based grid, with the axes, for understanding visual results
			function map(){
				const size = 100;
				const divisions = 100;
				const gridHelper = new THREE.GridHelper(size, divisions);
				scene.add(gridHelper);
				
				//The X axis is red, Y axis is green, Z axis is blue.
				const axesHelper = new THREE.AxesHelper( 100 );
				scene.add( axesHelper );
			}
			
			function polarMapCoordenates(){
				const polarHelper = new THREE.PolarGridHelper();
				scene.add(polarHelper);
			}
			
			// Generates a hill on the given geometry around the centerpoint
			function generateHill(geometry){
				var maxRadious = 5
				var radious = Math.random() * maxRadious + 1;
				var totalMountains = 500
				// Keep track of min and max height for normalization
				var max = Math.pow(maxRadious,2)
				var min = 0
				// Choose random mountain center
				for (var j=0; j < totalMountains; j++) {
					var randomLocation = Math.floor(Math.random() * geometry.attributes.position.count)
					var centerX = geometry.attributes.position.array[3*randomLocation];
					var centerZ = geometry.attributes.position.array[3*randomLocation+2];
					// Calculate height for points inside the radious (other points are 0)
					for (var i=0; i <geometry.attributes.position.count; i++) {
						var coordX = geometry.attributes.position.array[3*i+0];
						var coordZ = geometry.attributes.position.array[3*i+2];
						var y = Math.max(Math.pow(radious,2) - (Math.pow((coordX - centerX),2) + Math.pow((coordZ - centerZ),2)),0)
						if (y > max) {
							max = y;
						}
						geometry.attributes.position.array[3*i+1] += (y - min)/(max-min); 
					}
				}
			}

			// Generates random heights
			function addRandomHeights(geometry) {
				for (var i=0; i <geometry.attributes.position.count; i++) {
					geometry.attributes.position.array[3*i+1] = Math.floor(Math.random() *5); 
				}
			}

			function generateTexture(){
				// const texture = new THREE.TextureLoader().load( 'img/Heightmap.png');
				// return new THREE.MeshBasicMaterial( { map: texture } );

				var uniforms = {
					pointLight: {get value() {return pointlight_uniform}},
					diffuse: diffuse,
					color1: {value: new THREE.Color("red")},
					color2: {value: new THREE.Color("blue")}
				}

				var material = new THREE.ShaderMaterial(
				{
					uniforms: uniforms,
					vertexShader: `
						varying vec3 vPos; 
						varying vec3 vNormal;
						varying vec2 vUv; 
						void main() {
							vUv = uv;
						    vPos = (modelMatrix * vec4(position, 1.0 )).xyz;
							vNormal = normalMatrix * normal;
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
						} `,
					fragmentShader: `
						uniform vec3 color1;
						uniform vec3 color2;
						uniform vec3 diffuse;
						varying vec3 vPos;
						varying vec3 vNormal;
						varying vec2 vUv;

						struct PointLight {
							vec3 color;
							vec3 position;
							float distance;
						};
						uniform PointLight pointLight;

						void main() {
							vec4 addedLights = vec4(0.1, 0.1, 0.1, 1.0);
							vec3 lightDirection = normalize(vPos - pointLight.position);
							addedLights.rgb += clamp(dot(lightDirection, vNormal), 0.0, 1.0) * pointLight.color;
							// gl_FragColor = mix(vec4(mix(color1, color2, vUv.y), 1.0), addedLights, addedLights);
							gl_FragColor = mix(vec4(diffuse.x, diffuse.y, diffuse.z, 1.0), addedLights, addedLights);
						}
						`,
					side: THREE.DoubleSide,
					light: true
				});
				return material;
			}

			//with plane geometry
			function tarrain(){
				const width = 50; // Width along the X axis. Default is 1.
				const height = 50; // Height along the Y axis. Default is 1.
				const widthSegments = 1000; // Optional. Default is 1.
				const heightSegments = 1000; // Optional. Default is 1. 

				const geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
				geometry.rotateX(Math.PI/2);
				
				// Add heights
				// addRandomHeights(geometry);
				generateHill(geometry);

				const material = generateTexture();
				//const material = new THREE.MeshStandardMaterial({color:'white', side: THREE.DoubleSide});
				// var material = new THREE.MeshPhongMaterial({color: 0xdddddd, wireframe: true });
				const plane = new THREE.Mesh(geometry,material);
				plane.receiveShadow = true;
				scene.add(plane);
			}

			function render(){
				renderer.render(scene, camera);
			}

			function tick() {

				// Update Orbital Controls
				controls.update()

				// Render
				renderer.render(scene, camera)

				// Call tick again on the next frame
				window.requestAnimationFrame(tick)
			}
		</script>
	</body>
</html>