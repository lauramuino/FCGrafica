<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Heightmap</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<!-- todo: https://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html implementar esto -->
		<script src="./js/three.js"></script>
		<script type="module">
			import {OrbitControls} from './js/OrbitControls.js';
			var camera, scene, renderer;
			init();
			map();
			tarrain();
			render();			


			function init(){
				//setting camera
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set(10,0,0);
				camera.lookAt(scene.position);

				//todo: dont remember what this is
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//pointlight
				const pointLight = new THREE.PointLight(0xffffff, 2);
				pointLight.position.x = 2;
				pointLight.position.y = 3;
				pointLight.position.z = 4;
				scene.add(pointLight);

				//camera controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener( 'change', render );
				controls.target.y = camera.position.y;
				controls.update();
			}

			//todo: has a bug
			function manualMesh(){
				var size =2, step=1;
				var material = new THREE.LineBasicMaterial({color: 'white'});

				var geometry;
				var line;
				for(var i =-size; i<size; i+=step){
					const points = [];
					points.push(new THREE.Vector3(i, 0, i+1));
					points.push(new THREE.Vector3(size, 0, i));
					points.push(new THREE.Vector3(i, 0, -size));
					points.push(new THREE.Vector3(i, 0, size));

					geometry = new THREE.BufferGeometry().setFromPoints(points);
					line = new THREE.Line(geometry, material, THREE.LinePieces);
					scene.add(line);
				}
			}

			//the downside is not visible
 			function otherMesh(){
 				const geometry = new THREE.PlaneBufferGeometry(3,3,64,64);
 				const material = new THREE.MeshStandardMaterial({color:'white'});
 				const plane = new THREE.Mesh(geometry,material);
 				scene.add(plane);
 			}

			//a line based grid, with the helpers
			function map(){
				const size = 10;
				const divisions = 10;
				const gridHelper = new THREE.GridHelper(size, divisions);
				console.log(gridHelper);
				scene.add(gridHelper);

				//The X axis is red, Y axis is green, Z axis is blue.
				const axesHelper = new THREE.AxesHelper( 5 );
				scene.add( axesHelper );
			}

			function polarMapCoordenates(){
				const polarHelper = new THREE.PolarGridHelper();
				scene.add(polarHelper);
			}

			//with plane geometry
			function tarrain(){
				const width = 10; // Width along the X axis. Default is 1.
				const height = 10; // Height along the Y axis. Default is 1.
				const widthSegments = 1; // Optional. Default is 1.
				const heightSegments = 1; // Optional. Default is 1. 

				const geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);

				const material = new THREE.MeshStandardMaterial({color:'white'});
				const plane = new THREE.Mesh(geometry,material);
				scene.add(plane);
			}

			function aCube(){
				const geometry = new THREE.BoxGeometry( 1, 1, 1 );
				const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
				const cube = new THREE.Mesh( geometry, material );
				scene.add(cube);
			}

			function aLine(){
				const points = [];
				points.push(new THREE.Vector3(-10,0,0));
				points.push(new THREE.Vector3(0,0,10));
				points.push(new THREE.Vector3(10,0,0));


				const geometry = new THREE.BufferGeometry().setFromPoints( points );
				var material = new THREE.LineBasicMaterial({color: 'white'});
				const line = new THREE.Line( geometry, material );
				scene.add(line);
			}

			function render(){
				renderer.render(scene, camera);
			}

			function animate() {
				requestAnimationFrame( animate );
				plane.rotation.x += 0.01;
				plane.rotation.y += 0.01;
				renderer.render( scene, camera );
			}		
		</script>
	</body>
</html>